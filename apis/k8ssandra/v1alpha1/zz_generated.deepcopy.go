//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright 2022.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	"github.com/k8ssandra/cass-operator/apis/cassandra/v1beta1"
	medusav1alpha1 "github.com/k8ssandra/k8ssandra-operator/apis/medusa/v1alpha1"
	reaperv1alpha1 "github.com/k8ssandra/k8ssandra-operator/apis/reaper/v1alpha1"
	stargatev1alpha1 "github.com/k8ssandra/k8ssandra-operator/apis/stargate/v1alpha1"
	telemetryv1alpha1 "github.com/k8ssandra/k8ssandra-operator/apis/telemetry/v1alpha1"
	"github.com/k8ssandra/k8ssandra-operator/pkg/encryption"
	"github.com/k8ssandra/k8ssandra-operator/pkg/images"
	"k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *AuditLogOptions) DeepCopyInto(out *AuditLogOptions) {
	*out = *in
	if in.Logger != nil {
		in, out := &in.Logger, &out.Logger
		*out = new(ParameterizedClass)
		(*in).DeepCopyInto(*out)
	}
	if in.IncludedKeyspaces != nil {
		in, out := &in.IncludedKeyspaces, &out.IncludedKeyspaces
		*out = new(string)
		**out = **in
	}
	if in.IncludedCategories != nil {
		in, out := &in.IncludedCategories, &out.IncludedCategories
		*out = new(string)
		**out = **in
	}
	if in.IncludedUsers != nil {
		in, out := &in.IncludedUsers, &out.IncludedUsers
		*out = new(string)
		**out = **in
	}
	if in.ExcludedUsers != nil {
		in, out := &in.ExcludedUsers, &out.ExcludedUsers
		*out = new(string)
		**out = **in
	}
	if in.RollCycle != nil {
		in, out := &in.RollCycle, &out.RollCycle
		*out = new(string)
		**out = **in
	}
	if in.Block != nil {
		in, out := &in.Block, &out.Block
		*out = new(bool)
		**out = **in
	}
	if in.MaxQueueWeight != nil {
		in, out := &in.MaxQueueWeight, &out.MaxQueueWeight
		*out = new(int)
		**out = **in
	}
	if in.MaxLogSize != nil {
		in, out := &in.MaxLogSize, &out.MaxLogSize
		*out = new(int)
		**out = **in
	}
	if in.ArchiveCommand != nil {
		in, out := &in.ArchiveCommand, &out.ArchiveCommand
		*out = new(string)
		**out = **in
	}
	if in.MaxArchiveRetries != nil {
		in, out := &in.MaxArchiveRetries, &out.MaxArchiveRetries
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new AuditLogOptions.
func (in *AuditLogOptions) DeepCopy() *AuditLogOptions {
	if in == nil {
		return nil
	}
	out := new(AuditLogOptions)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CassandraClusterTemplate) DeepCopyInto(out *CassandraClusterTemplate) {
	*out = *in
	out.SuperuserSecretRef = in.SuperuserSecretRef
	if in.JmxInitContainerImage != nil {
		in, out := &in.JmxInitContainerImage, &out.JmxInitContainerImage
		*out = new(images.Image)
		(*in).DeepCopyInto(*out)
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.CassandraConfig != nil {
		in, out := &in.CassandraConfig, &out.CassandraConfig
		*out = new(CassandraConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.StorageConfig != nil {
		in, out := &in.StorageConfig, &out.StorageConfig
		*out = new(v1beta1.StorageConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.Networking != nil {
		in, out := &in.Networking, &out.Networking
		*out = new(v1beta1.NetworkingConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.Racks != nil {
		in, out := &in.Racks, &out.Racks
		*out = make([]v1beta1.Rack, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Datacenters != nil {
		in, out := &in.Datacenters, &out.Datacenters
		*out = make([]CassandraDatacenterTemplate, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Telemetry != nil {
		in, out := &in.Telemetry, &out.Telemetry
		*out = new(telemetryv1alpha1.TelemetrySpec)
		(*in).DeepCopyInto(*out)
	}
	if in.MgmtAPIHeap != nil {
		in, out := &in.MgmtAPIHeap, &out.MgmtAPIHeap
		x := (*in).DeepCopy()
		*out = &x
	}
	if in.AdditionalSeeds != nil {
		in, out := &in.AdditionalSeeds, &out.AdditionalSeeds
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
	if in.SoftPodAntiAffinity != nil {
		in, out := &in.SoftPodAntiAffinity, &out.SoftPodAntiAffinity
		*out = new(bool)
		**out = **in
	}
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.ServerEncryptionStores != nil {
		in, out := &in.ServerEncryptionStores, &out.ServerEncryptionStores
		*out = new(encryption.Stores)
		**out = **in
	}
	if in.ClientEncryptionStores != nil {
		in, out := &in.ClientEncryptionStores, &out.ClientEncryptionStores
		*out = new(encryption.Stores)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CassandraClusterTemplate.
func (in *CassandraClusterTemplate) DeepCopy() *CassandraClusterTemplate {
	if in == nil {
		return nil
	}
	out := new(CassandraClusterTemplate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CassandraConfig) DeepCopyInto(out *CassandraConfig) {
	*out = *in
	in.CassandraYaml.DeepCopyInto(&out.CassandraYaml)
	in.JvmOptions.DeepCopyInto(&out.JvmOptions)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CassandraConfig.
func (in *CassandraConfig) DeepCopy() *CassandraConfig {
	if in == nil {
		return nil
	}
	out := new(CassandraConfig)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CassandraDatacenterTemplate) DeepCopyInto(out *CassandraDatacenterTemplate) {
	*out = *in
	in.Meta.DeepCopyInto(&out.Meta)
	if in.JmxInitContainerImage != nil {
		in, out := &in.JmxInitContainerImage, &out.JmxInitContainerImage
		*out = new(images.Image)
		(*in).DeepCopyInto(*out)
	}
	if in.CassandraConfig != nil {
		in, out := &in.CassandraConfig, &out.CassandraConfig
		*out = new(CassandraConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.Resources != nil {
		in, out := &in.Resources, &out.Resources
		*out = new(v1.ResourceRequirements)
		(*in).DeepCopyInto(*out)
	}
	if in.Racks != nil {
		in, out := &in.Racks, &out.Racks
		*out = make([]v1beta1.Rack, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Networking != nil {
		in, out := &in.Networking, &out.Networking
		*out = new(v1beta1.NetworkingConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.StorageConfig != nil {
		in, out := &in.StorageConfig, &out.StorageConfig
		*out = new(v1beta1.StorageConfig)
		(*in).DeepCopyInto(*out)
	}
	if in.Stargate != nil {
		in, out := &in.Stargate, &out.Stargate
		*out = new(stargatev1alpha1.StargateDatacenterTemplate)
		(*in).DeepCopyInto(*out)
	}
	if in.MgmtAPIHeap != nil {
		in, out := &in.MgmtAPIHeap, &out.MgmtAPIHeap
		x := (*in).DeepCopy()
		*out = &x
	}
	if in.Telemetry != nil {
		in, out := &in.Telemetry, &out.Telemetry
		*out = new(telemetryv1alpha1.TelemetrySpec)
		(*in).DeepCopyInto(*out)
	}
	if in.SoftPodAntiAffinity != nil {
		in, out := &in.SoftPodAntiAffinity, &out.SoftPodAntiAffinity
		*out = new(bool)
		**out = **in
	}
	if in.Tolerations != nil {
		in, out := &in.Tolerations, &out.Tolerations
		*out = make([]v1.Toleration, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CassandraDatacenterTemplate.
func (in *CassandraDatacenterTemplate) DeepCopy() *CassandraDatacenterTemplate {
	if in == nil {
		return nil
	}
	out := new(CassandraDatacenterTemplate)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *CassandraYaml) DeepCopyInto(out *CassandraYaml) {
	*out = *in
	if in.AllocateTokensForKeyspace != nil {
		in, out := &in.AllocateTokensForKeyspace, &out.AllocateTokensForKeyspace
		*out = new(string)
		**out = **in
	}
	if in.AllocateTokensForLocalReplicationFactor != nil {
		in, out := &in.AllocateTokensForLocalReplicationFactor, &out.AllocateTokensForLocalReplicationFactor
		*out = new(int)
		**out = **in
	}
	if in.AuditLoggingOptions != nil {
		in, out := &in.AuditLoggingOptions, &out.AuditLoggingOptions
		*out = new(AuditLogOptions)
		(*in).DeepCopyInto(*out)
	}
	if in.AuthReadConsistencyLevel != nil {
		in, out := &in.AuthReadConsistencyLevel, &out.AuthReadConsistencyLevel
		*out = new(string)
		**out = **in
	}
	if in.AuthWriteConsistencyLevel != nil {
		in, out := &in.AuthWriteConsistencyLevel, &out.AuthWriteConsistencyLevel
		*out = new(string)
		**out = **in
	}
	if in.Authenticator != nil {
		in, out := &in.Authenticator, &out.Authenticator
		*out = new(string)
		**out = **in
	}
	if in.Authorizer != nil {
		in, out := &in.Authorizer, &out.Authorizer
		*out = new(string)
		**out = **in
	}
	if in.AutoHintsCleanupEnabled != nil {
		in, out := &in.AutoHintsCleanupEnabled, &out.AutoHintsCleanupEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AutoOptimiseFullRepairStreams != nil {
		in, out := &in.AutoOptimiseFullRepairStreams, &out.AutoOptimiseFullRepairStreams
		*out = new(bool)
		**out = **in
	}
	if in.AutoOptimiseIncRepairStreams != nil {
		in, out := &in.AutoOptimiseIncRepairStreams, &out.AutoOptimiseIncRepairStreams
		*out = new(bool)
		**out = **in
	}
	if in.AutoOptimisePreviewRepairStreams != nil {
		in, out := &in.AutoOptimisePreviewRepairStreams, &out.AutoOptimisePreviewRepairStreams
		*out = new(bool)
		**out = **in
	}
	if in.AutoSnapshot != nil {
		in, out := &in.AutoSnapshot, &out.AutoSnapshot
		*out = new(bool)
		**out = **in
	}
	if in.AutocompactionOnStartupEnabled != nil {
		in, out := &in.AutocompactionOnStartupEnabled, &out.AutocompactionOnStartupEnabled
		*out = new(bool)
		**out = **in
	}
	if in.AutomaticSstableUpgrade != nil {
		in, out := &in.AutomaticSstableUpgrade, &out.AutomaticSstableUpgrade
		*out = new(bool)
		**out = **in
	}
	if in.AvailableProcessors != nil {
		in, out := &in.AvailableProcessors, &out.AvailableProcessors
		*out = new(int)
		**out = **in
	}
	if in.BackPressureEnabled != nil {
		in, out := &in.BackPressureEnabled, &out.BackPressureEnabled
		*out = new(bool)
		**out = **in
	}
	if in.BackPressureStrategy != nil {
		in, out := &in.BackPressureStrategy, &out.BackPressureStrategy
		*out = new(ParameterizedClass)
		(*in).DeepCopyInto(*out)
	}
	if in.BatchSizeFailThresholdInKb != nil {
		in, out := &in.BatchSizeFailThresholdInKb, &out.BatchSizeFailThresholdInKb
		*out = new(int)
		**out = **in
	}
	if in.BatchSizeWarnThresholdInKb != nil {
		in, out := &in.BatchSizeWarnThresholdInKb, &out.BatchSizeWarnThresholdInKb
		*out = new(int)
		**out = **in
	}
	if in.BatchlogReplayThrottleInKb != nil {
		in, out := &in.BatchlogReplayThrottleInKb, &out.BatchlogReplayThrottleInKb
		*out = new(int)
		**out = **in
	}
	if in.BlockForPeersInRemoteDcs != nil {
		in, out := &in.BlockForPeersInRemoteDcs, &out.BlockForPeersInRemoteDcs
		*out = new(bool)
		**out = **in
	}
	if in.BlockForPeersTimeoutInSecs != nil {
		in, out := &in.BlockForPeersTimeoutInSecs, &out.BlockForPeersTimeoutInSecs
		*out = new(int)
		**out = **in
	}
	if in.BufferPoolUseHeapIfExhausted != nil {
		in, out := &in.BufferPoolUseHeapIfExhausted, &out.BufferPoolUseHeapIfExhausted
		*out = new(bool)
		**out = **in
	}
	if in.CasContentionTimeoutInMs != nil {
		in, out := &in.CasContentionTimeoutInMs, &out.CasContentionTimeoutInMs
		*out = new(int)
		**out = **in
	}
	if in.CdcEnabled != nil {
		in, out := &in.CdcEnabled, &out.CdcEnabled
		*out = new(bool)
		**out = **in
	}
	if in.CdcFreeSpaceCheckIntervalMs != nil {
		in, out := &in.CdcFreeSpaceCheckIntervalMs, &out.CdcFreeSpaceCheckIntervalMs
		*out = new(int)
		**out = **in
	}
	if in.CdcRawDirectory != nil {
		in, out := &in.CdcRawDirectory, &out.CdcRawDirectory
		*out = new(string)
		**out = **in
	}
	if in.CdcTotalSpaceInMb != nil {
		in, out := &in.CdcTotalSpaceInMb, &out.CdcTotalSpaceInMb
		*out = new(int)
		**out = **in
	}
	if in.CheckForDuplicateRowsDuringCompaction != nil {
		in, out := &in.CheckForDuplicateRowsDuringCompaction, &out.CheckForDuplicateRowsDuringCompaction
		*out = new(bool)
		**out = **in
	}
	if in.CheckForDuplicateRowsDuringReads != nil {
		in, out := &in.CheckForDuplicateRowsDuringReads, &out.CheckForDuplicateRowsDuringReads
		*out = new(bool)
		**out = **in
	}
	if in.ClientEncryptionOptions != nil {
		in, out := &in.ClientEncryptionOptions, &out.ClientEncryptionOptions
		*out = new(encryption.ClientEncryptionOptions)
		(*in).DeepCopyInto(*out)
	}
	if in.ClientErrorReportingExclusions != nil {
		in, out := &in.ClientErrorReportingExclusions, &out.ClientErrorReportingExclusions
		*out = new(SubnetGroups)
		(*in).DeepCopyInto(*out)
	}
	if in.ColumnIndexCacheSizeInKb != nil {
		in, out := &in.ColumnIndexCacheSizeInKb, &out.ColumnIndexCacheSizeInKb
		*out = new(int)
		**out = **in
	}
	if in.ColumnIndexSizeInKb != nil {
		in, out := &in.ColumnIndexSizeInKb, &out.ColumnIndexSizeInKb
		*out = new(int)
		**out = **in
	}
	if in.CommitlogCompression != nil {
		in, out := &in.CommitlogCompression, &out.CommitlogCompression
		*out = new(ParameterizedClass)
		(*in).DeepCopyInto(*out)
	}
	if in.CommitlogMaxCompressionBuffersInPool != nil {
		in, out := &in.CommitlogMaxCompressionBuffersInPool, &out.CommitlogMaxCompressionBuffersInPool
		*out = new(int)
		**out = **in
	}
	if in.CommitlogPeriodicQueueSize != nil {
		in, out := &in.CommitlogPeriodicQueueSize, &out.CommitlogPeriodicQueueSize
		*out = new(int)
		**out = **in
	}
	if in.CommitlogSegmentSizeInMb != nil {
		in, out := &in.CommitlogSegmentSizeInMb, &out.CommitlogSegmentSizeInMb
		*out = new(int)
		**out = **in
	}
	if in.CommitlogSync != nil {
		in, out := &in.CommitlogSync, &out.CommitlogSync
		*out = new(string)
		**out = **in
	}
	if in.CommitlogSyncBatchWindowInMs != nil {
		in, out := &in.CommitlogSyncBatchWindowInMs, &out.CommitlogSyncBatchWindowInMs
		*out = new(string)
		**out = **in
	}
	if in.CommitlogSyncGroupWindowInMs != nil {
		in, out := &in.CommitlogSyncGroupWindowInMs, &out.CommitlogSyncGroupWindowInMs
		*out = new(int)
		**out = **in
	}
	if in.CommitlogSyncPeriodInMs != nil {
		in, out := &in.CommitlogSyncPeriodInMs, &out.CommitlogSyncPeriodInMs
		*out = new(int)
		**out = **in
	}
	if in.CommitlogTotalSpaceInMb != nil {
		in, out := &in.CommitlogTotalSpaceInMb, &out.CommitlogTotalSpaceInMb
		*out = new(int)
		**out = **in
	}
	if in.CompactionLargePartitionWarningThresholdMb != nil {
		in, out := &in.CompactionLargePartitionWarningThresholdMb, &out.CompactionLargePartitionWarningThresholdMb
		*out = new(int)
		**out = **in
	}
	if in.CompactionThroughputMbPerSec != nil {
		in, out := &in.CompactionThroughputMbPerSec, &out.CompactionThroughputMbPerSec
		*out = new(int)
		**out = **in
	}
	if in.CompactionTombstoneWarningThreshold != nil {
		in, out := &in.CompactionTombstoneWarningThreshold, &out.CompactionTombstoneWarningThreshold
		*out = new(int)
		**out = **in
	}
	if in.ConcurrentCompactors != nil {
		in, out := &in.ConcurrentCompactors, &out.ConcurrentCompactors
		*out = new(int)
		**out = **in
	}
	if in.ConcurrentCounterWrites != nil {
		in, out := &in.ConcurrentCounterWrites, &out.ConcurrentCounterWrites
		*out = new(int)
		**out = **in
	}
	if in.ConcurrentMaterializedViewBuilders != nil {
		in, out := &in.ConcurrentMaterializedViewBuilders, &out.ConcurrentMaterializedViewBuilders
		*out = new(int)
		**out = **in
	}
	if in.ConcurrentMaterializedViewWrites != nil {
		in, out := &in.ConcurrentMaterializedViewWrites, &out.ConcurrentMaterializedViewWrites
		*out = new(int)
		**out = **in
	}
	if in.ConcurrentReads != nil {
		in, out := &in.ConcurrentReads, &out.ConcurrentReads
		*out = new(int)
		**out = **in
	}
	if in.ConcurrentReplicates != nil {
		in, out := &in.ConcurrentReplicates, &out.ConcurrentReplicates
		*out = new(int)
		**out = **in
	}
	if in.ConcurrentValidations != nil {
		in, out := &in.ConcurrentValidations, &out.ConcurrentValidations
		*out = new(int)
		**out = **in
	}
	if in.ConcurrentWrites != nil {
		in, out := &in.ConcurrentWrites, &out.ConcurrentWrites
		*out = new(int)
		**out = **in
	}
	if in.ConsecutiveMessageErrorsThreshold != nil {
		in, out := &in.ConsecutiveMessageErrorsThreshold, &out.ConsecutiveMessageErrorsThreshold
		*out = new(int)
		**out = **in
	}
	if in.CorruptedTombstoneStrategy != nil {
		in, out := &in.CorruptedTombstoneStrategy, &out.CorruptedTombstoneStrategy
		*out = new(string)
		**out = **in
	}
	if in.CounterCacheKeysToSave != nil {
		in, out := &in.CounterCacheKeysToSave, &out.CounterCacheKeysToSave
		*out = new(int)
		**out = **in
	}
	if in.CounterCacheSavePeriod != nil {
		in, out := &in.CounterCacheSavePeriod, &out.CounterCacheSavePeriod
		*out = new(int)
		**out = **in
	}
	if in.CounterCacheSizeInMb != nil {
		in, out := &in.CounterCacheSizeInMb, &out.CounterCacheSizeInMb
		*out = new(int)
		**out = **in
	}
	if in.CounterWriteRequestTimeoutInMs != nil {
		in, out := &in.CounterWriteRequestTimeoutInMs, &out.CounterWriteRequestTimeoutInMs
		*out = new(int)
		**out = **in
	}
	if in.CredentialsCacheMaxEntries != nil {
		in, out := &in.CredentialsCacheMaxEntries, &out.CredentialsCacheMaxEntries
		*out = new(int)
		**out = **in
	}
	if in.CredentialsUpdateIntervalInMs != nil {
		in, out := &in.CredentialsUpdateIntervalInMs, &out.CredentialsUpdateIntervalInMs
		*out = new(int)
		**out = **in
	}
	if in.CredentialsValidityInMs != nil {
		in, out := &in.CredentialsValidityInMs, &out.CredentialsValidityInMs
		*out = new(int)
		**out = **in
	}
	if in.CrossNodeTimeout != nil {
		in, out := &in.CrossNodeTimeout, &out.CrossNodeTimeout
		*out = new(bool)
		**out = **in
	}
	if in.DefaultKeyspaceRf != nil {
		in, out := &in.DefaultKeyspaceRf, &out.DefaultKeyspaceRf
		*out = new(int)
		**out = **in
	}
	if in.DenylistConsistencyLevel != nil {
		in, out := &in.DenylistConsistencyLevel, &out.DenylistConsistencyLevel
		*out = new(string)
		**out = **in
	}
	if in.DenylistInitialLoadRetrySeconds != nil {
		in, out := &in.DenylistInitialLoadRetrySeconds, &out.DenylistInitialLoadRetrySeconds
		*out = new(int)
		**out = **in
	}
	if in.DenylistMaxKeysPerTable != nil {
		in, out := &in.DenylistMaxKeysPerTable, &out.DenylistMaxKeysPerTable
		*out = new(int)
		**out = **in
	}
	if in.DenylistMaxKeysTotal != nil {
		in, out := &in.DenylistMaxKeysTotal, &out.DenylistMaxKeysTotal
		*out = new(int)
		**out = **in
	}
	if in.DenylistRefreshSeconds != nil {
		in, out := &in.DenylistRefreshSeconds, &out.DenylistRefreshSeconds
		*out = new(int)
		**out = **in
	}
	if in.DiagnosticEventsEnabled != nil {
		in, out := &in.DiagnosticEventsEnabled, &out.DiagnosticEventsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.DiskAccessMode != nil {
		in, out := &in.DiskAccessMode, &out.DiskAccessMode
		*out = new(string)
		**out = **in
	}
	if in.DiskOptimizationEstimatePercentile != nil {
		in, out := &in.DiskOptimizationEstimatePercentile, &out.DiskOptimizationEstimatePercentile
		*out = new(string)
		**out = **in
	}
	if in.DiskOptimizationPageCrossChance != nil {
		in, out := &in.DiskOptimizationPageCrossChance, &out.DiskOptimizationPageCrossChance
		*out = new(string)
		**out = **in
	}
	if in.DiskOptimizationStrategy != nil {
		in, out := &in.DiskOptimizationStrategy, &out.DiskOptimizationStrategy
		*out = new(string)
		**out = **in
	}
	if in.DynamicSnitch != nil {
		in, out := &in.DynamicSnitch, &out.DynamicSnitch
		*out = new(bool)
		**out = **in
	}
	if in.DynamicSnitchBadnessThreshold != nil {
		in, out := &in.DynamicSnitchBadnessThreshold, &out.DynamicSnitchBadnessThreshold
		*out = new(string)
		**out = **in
	}
	if in.DynamicSnitchResetIntervalInMs != nil {
		in, out := &in.DynamicSnitchResetIntervalInMs, &out.DynamicSnitchResetIntervalInMs
		*out = new(int)
		**out = **in
	}
	if in.DynamicSnitchUpdateIntervalInMs != nil {
		in, out := &in.DynamicSnitchUpdateIntervalInMs, &out.DynamicSnitchUpdateIntervalInMs
		*out = new(int)
		**out = **in
	}
	if in.EnableDenylistRangeReads != nil {
		in, out := &in.EnableDenylistRangeReads, &out.EnableDenylistRangeReads
		*out = new(bool)
		**out = **in
	}
	if in.EnableDenylistReads != nil {
		in, out := &in.EnableDenylistReads, &out.EnableDenylistReads
		*out = new(bool)
		**out = **in
	}
	if in.EnableDenylistWrites != nil {
		in, out := &in.EnableDenylistWrites, &out.EnableDenylistWrites
		*out = new(bool)
		**out = **in
	}
	if in.EnableDropCompactStorage != nil {
		in, out := &in.EnableDropCompactStorage, &out.EnableDropCompactStorage
		*out = new(bool)
		**out = **in
	}
	if in.EnableMaterializedViews != nil {
		in, out := &in.EnableMaterializedViews, &out.EnableMaterializedViews
		*out = new(bool)
		**out = **in
	}
	if in.EnablePartitionDenylist != nil {
		in, out := &in.EnablePartitionDenylist, &out.EnablePartitionDenylist
		*out = new(bool)
		**out = **in
	}
	if in.EnableSasiIndexes != nil {
		in, out := &in.EnableSasiIndexes, &out.EnableSasiIndexes
		*out = new(bool)
		**out = **in
	}
	if in.EnableScriptedUserDefinedFunctions != nil {
		in, out := &in.EnableScriptedUserDefinedFunctions, &out.EnableScriptedUserDefinedFunctions
		*out = new(bool)
		**out = **in
	}
	if in.EnableTransientReplication != nil {
		in, out := &in.EnableTransientReplication, &out.EnableTransientReplication
		*out = new(bool)
		**out = **in
	}
	if in.EnableUserDefinedFunctions != nil {
		in, out := &in.EnableUserDefinedFunctions, &out.EnableUserDefinedFunctions
		*out = new(bool)
		**out = **in
	}
	if in.EnableUserDefinedFunctionsThreads != nil {
		in, out := &in.EnableUserDefinedFunctionsThreads, &out.EnableUserDefinedFunctionsThreads
		*out = new(bool)
		**out = **in
	}
	if in.EndpointSnitch != nil {
		in, out := &in.EndpointSnitch, &out.EndpointSnitch
		*out = new(string)
		**out = **in
	}
	if in.FailureDetector != nil {
		in, out := &in.FailureDetector, &out.FailureDetector
		*out = new(string)
		**out = **in
	}
	if in.FileCacheEnabled != nil {
		in, out := &in.FileCacheEnabled, &out.FileCacheEnabled
		*out = new(bool)
		**out = **in
	}
	if in.FileCacheRoundUp != nil {
		in, out := &in.FileCacheRoundUp, &out.FileCacheRoundUp
		*out = new(bool)
		**out = **in
	}
	if in.FileCacheSizeInMb != nil {
		in, out := &in.FileCacheSizeInMb, &out.FileCacheSizeInMb
		*out = new(int)
		**out = **in
	}
	if in.FlushCompression != nil {
		in, out := &in.FlushCompression, &out.FlushCompression
		*out = new(string)
		**out = **in
	}
	if in.FullQueryLoggingOptions != nil {
		in, out := &in.FullQueryLoggingOptions, &out.FullQueryLoggingOptions
		*out = new(FullQueryLoggerOptions)
		(*in).DeepCopyInto(*out)
	}
	if in.GcLogThresholdInMs != nil {
		in, out := &in.GcLogThresholdInMs, &out.GcLogThresholdInMs
		*out = new(int)
		**out = **in
	}
	if in.GcWarnThresholdInMs != nil {
		in, out := &in.GcWarnThresholdInMs, &out.GcWarnThresholdInMs
		*out = new(int)
		**out = **in
	}
	if in.HintWindowPersistentEnabled != nil {
		in, out := &in.HintWindowPersistentEnabled, &out.HintWindowPersistentEnabled
		*out = new(bool)
		**out = **in
	}
	if in.HintedHandoffDisabledDatacenters != nil {
		in, out := &in.HintedHandoffDisabledDatacenters, &out.HintedHandoffDisabledDatacenters
		*out = new([]string)
		if **in != nil {
			in, out := *in, *out
			*out = make([]string, len(*in))
			copy(*out, *in)
		}
	}
	if in.HintedHandoffEnabled != nil {
		in, out := &in.HintedHandoffEnabled, &out.HintedHandoffEnabled
		*out = new(bool)
		**out = **in
	}
	if in.HintedHandoffThrottleInKb != nil {
		in, out := &in.HintedHandoffThrottleInKb, &out.HintedHandoffThrottleInKb
		*out = new(int)
		**out = **in
	}
	if in.HintsCompression != nil {
		in, out := &in.HintsCompression, &out.HintsCompression
		*out = new(ParameterizedClass)
		(*in).DeepCopyInto(*out)
	}
	if in.HintsFlushPeriodInMs != nil {
		in, out := &in.HintsFlushPeriodInMs, &out.HintsFlushPeriodInMs
		*out = new(int)
		**out = **in
	}
	if in.IdealConsistencyLevel != nil {
		in, out := &in.IdealConsistencyLevel, &out.IdealConsistencyLevel
		*out = new(string)
		**out = **in
	}
	if in.IndexInterval != nil {
		in, out := &in.IndexInterval, &out.IndexInterval
		*out = new(int)
		**out = **in
	}
	if in.IndexSummaryCapacityInMb != nil {
		in, out := &in.IndexSummaryCapacityInMb, &out.IndexSummaryCapacityInMb
		*out = new(int)
		**out = **in
	}
	if in.IndexSummaryResizeIntervalInMinutes != nil {
		in, out := &in.IndexSummaryResizeIntervalInMinutes, &out.IndexSummaryResizeIntervalInMinutes
		*out = new(int)
		**out = **in
	}
	if in.InitialRangeTombstoneListAllocationSize != nil {
		in, out := &in.InitialRangeTombstoneListAllocationSize, &out.InitialRangeTombstoneListAllocationSize
		*out = new(int)
		**out = **in
	}
	if in.InterDcStreamThroughputOutboundMegabitsPerSec != nil {
		in, out := &in.InterDcStreamThroughputOutboundMegabitsPerSec, &out.InterDcStreamThroughputOutboundMegabitsPerSec
		*out = new(int)
		**out = **in
	}
	if in.InterDcTcpNodelay != nil {
		in, out := &in.InterDcTcpNodelay, &out.InterDcTcpNodelay
		*out = new(bool)
		**out = **in
	}
	if in.InternodeApplicationReceiveQueueCapacityInBytes != nil {
		in, out := &in.InternodeApplicationReceiveQueueCapacityInBytes, &out.InternodeApplicationReceiveQueueCapacityInBytes
		*out = new(int)
		**out = **in
	}
	if in.InternodeApplicationReceiveQueueReserveEndpointCapacityInBytes != nil {
		in, out := &in.InternodeApplicationReceiveQueueReserveEndpointCapacityInBytes, &out.InternodeApplicationReceiveQueueReserveEndpointCapacityInBytes
		*out = new(int)
		**out = **in
	}
	if in.InternodeApplicationReceiveQueueReserveGlobalCapacityInBytes != nil {
		in, out := &in.InternodeApplicationReceiveQueueReserveGlobalCapacityInBytes, &out.InternodeApplicationReceiveQueueReserveGlobalCapacityInBytes
		*out = new(int)
		**out = **in
	}
	if in.InternodeApplicationSendQueueCapacityInBytes != nil {
		in, out := &in.InternodeApplicationSendQueueCapacityInBytes, &out.InternodeApplicationSendQueueCapacityInBytes
		*out = new(int)
		**out = **in
	}
	if in.InternodeApplicationSendQueueReserveEndpointCapacityInBytes != nil {
		in, out := &in.InternodeApplicationSendQueueReserveEndpointCapacityInBytes, &out.InternodeApplicationSendQueueReserveEndpointCapacityInBytes
		*out = new(int)
		**out = **in
	}
	if in.InternodeApplicationSendQueueReserveGlobalCapacityInBytes != nil {
		in, out := &in.InternodeApplicationSendQueueReserveGlobalCapacityInBytes, &out.InternodeApplicationSendQueueReserveGlobalCapacityInBytes
		*out = new(int)
		**out = **in
	}
	if in.InternodeAuthenticator != nil {
		in, out := &in.InternodeAuthenticator, &out.InternodeAuthenticator
		*out = new(string)
		**out = **in
	}
	if in.InternodeCompression != nil {
		in, out := &in.InternodeCompression, &out.InternodeCompression
		*out = new(string)
		**out = **in
	}
	if in.InternodeErrorReportingExclusions != nil {
		in, out := &in.InternodeErrorReportingExclusions, &out.InternodeErrorReportingExclusions
		*out = new(SubnetGroups)
		(*in).DeepCopyInto(*out)
	}
	if in.InternodeMaxMessageSizeInBytes != nil {
		in, out := &in.InternodeMaxMessageSizeInBytes, &out.InternodeMaxMessageSizeInBytes
		*out = new(int)
		**out = **in
	}
	if in.InternodeRecvBuffSizeInBytes != nil {
		in, out := &in.InternodeRecvBuffSizeInBytes, &out.InternodeRecvBuffSizeInBytes
		*out = new(int)
		**out = **in
	}
	if in.InternodeSendBuffSizeInBytes != nil {
		in, out := &in.InternodeSendBuffSizeInBytes, &out.InternodeSendBuffSizeInBytes
		*out = new(int)
		**out = **in
	}
	if in.InternodeSocketReceiveBufferSizeInBytes != nil {
		in, out := &in.InternodeSocketReceiveBufferSizeInBytes, &out.InternodeSocketReceiveBufferSizeInBytes
		*out = new(int)
		**out = **in
	}
	if in.InternodeSocketSendBufferSizeInBytes != nil {
		in, out := &in.InternodeSocketSendBufferSizeInBytes, &out.InternodeSocketSendBufferSizeInBytes
		*out = new(int)
		**out = **in
	}
	if in.InternodeStreamingTcpUserTimeoutInMs != nil {
		in, out := &in.InternodeStreamingTcpUserTimeoutInMs, &out.InternodeStreamingTcpUserTimeoutInMs
		*out = new(int)
		**out = **in
	}
	if in.InternodeTcpConnectTimeoutInMs != nil {
		in, out := &in.InternodeTcpConnectTimeoutInMs, &out.InternodeTcpConnectTimeoutInMs
		*out = new(int)
		**out = **in
	}
	if in.InternodeTcpUserTimeoutInMs != nil {
		in, out := &in.InternodeTcpUserTimeoutInMs, &out.InternodeTcpUserTimeoutInMs
		*out = new(int)
		**out = **in
	}
	if in.KeyCacheKeysToSave != nil {
		in, out := &in.KeyCacheKeysToSave, &out.KeyCacheKeysToSave
		*out = new(int)
		**out = **in
	}
	if in.KeyCacheMigrateDuringCompaction != nil {
		in, out := &in.KeyCacheMigrateDuringCompaction, &out.KeyCacheMigrateDuringCompaction
		*out = new(bool)
		**out = **in
	}
	if in.KeyCacheSavePeriod != nil {
		in, out := &in.KeyCacheSavePeriod, &out.KeyCacheSavePeriod
		*out = new(int)
		**out = **in
	}
	if in.KeyCacheSizeInMb != nil {
		in, out := &in.KeyCacheSizeInMb, &out.KeyCacheSizeInMb
		*out = new(int)
		**out = **in
	}
	if in.KeyspaceCountWarnThreshold != nil {
		in, out := &in.KeyspaceCountWarnThreshold, &out.KeyspaceCountWarnThreshold
		*out = new(int)
		**out = **in
	}
	if in.MaxConcurrentAutomaticSstableUpgrades != nil {
		in, out := &in.MaxConcurrentAutomaticSstableUpgrades, &out.MaxConcurrentAutomaticSstableUpgrades
		*out = new(int)
		**out = **in
	}
	if in.MaxHintWindowInMs != nil {
		in, out := &in.MaxHintWindowInMs, &out.MaxHintWindowInMs
		*out = new(int)
		**out = **in
	}
	if in.MaxHintsDeliveryThreads != nil {
		in, out := &in.MaxHintsDeliveryThreads, &out.MaxHintsDeliveryThreads
		*out = new(int)
		**out = **in
	}
	if in.MaxHintsFileSizeInMb != nil {
		in, out := &in.MaxHintsFileSizeInMb, &out.MaxHintsFileSizeInMb
		*out = new(int)
		**out = **in
	}
	if in.MaxMutationSizeInKb != nil {
		in, out := &in.MaxMutationSizeInKb, &out.MaxMutationSizeInKb
		*out = new(int)
		**out = **in
	}
	if in.MaxStreamingRetries != nil {
		in, out := &in.MaxStreamingRetries, &out.MaxStreamingRetries
		*out = new(int)
		**out = **in
	}
	if in.MaxValueSizeInMb != nil {
		in, out := &in.MaxValueSizeInMb, &out.MaxValueSizeInMb
		*out = new(int)
		**out = **in
	}
	if in.MemtableAllocationType != nil {
		in, out := &in.MemtableAllocationType, &out.MemtableAllocationType
		*out = new(string)
		**out = **in
	}
	if in.MemtableCleanupThreshold != nil {
		in, out := &in.MemtableCleanupThreshold, &out.MemtableCleanupThreshold
		*out = new(string)
		**out = **in
	}
	if in.MemtableFlushWriters != nil {
		in, out := &in.MemtableFlushWriters, &out.MemtableFlushWriters
		*out = new(int)
		**out = **in
	}
	if in.MemtableHeapSpaceInMb != nil {
		in, out := &in.MemtableHeapSpaceInMb, &out.MemtableHeapSpaceInMb
		*out = new(int)
		**out = **in
	}
	if in.MemtableOffheapSpaceInMb != nil {
		in, out := &in.MemtableOffheapSpaceInMb, &out.MemtableOffheapSpaceInMb
		*out = new(int)
		**out = **in
	}
	if in.MinFreeSpacePerDriveInMb != nil {
		in, out := &in.MinFreeSpacePerDriveInMb, &out.MinFreeSpacePerDriveInMb
		*out = new(int)
		**out = **in
	}
	if in.MinimumKeyspaceRf != nil {
		in, out := &in.MinimumKeyspaceRf, &out.MinimumKeyspaceRf
		*out = new(int)
		**out = **in
	}
	if in.NativeTransportAllowOlderProtocols != nil {
		in, out := &in.NativeTransportAllowOlderProtocols, &out.NativeTransportAllowOlderProtocols
		*out = new(bool)
		**out = **in
	}
	if in.NativeTransportFlushInBatchesLegacy != nil {
		in, out := &in.NativeTransportFlushInBatchesLegacy, &out.NativeTransportFlushInBatchesLegacy
		*out = new(bool)
		**out = **in
	}
	if in.NativeTransportIdleTimeoutInMs != nil {
		in, out := &in.NativeTransportIdleTimeoutInMs, &out.NativeTransportIdleTimeoutInMs
		*out = new(int)
		**out = **in
	}
	if in.NativeTransportMaxConcurrentConnections != nil {
		in, out := &in.NativeTransportMaxConcurrentConnections, &out.NativeTransportMaxConcurrentConnections
		*out = new(int)
		**out = **in
	}
	if in.NativeTransportMaxConcurrentConnectionsPerIp != nil {
		in, out := &in.NativeTransportMaxConcurrentConnectionsPerIp, &out.NativeTransportMaxConcurrentConnectionsPerIp
		*out = new(int)
		**out = **in
	}
	if in.NativeTransportMaxConcurrentRequestsInBytes != nil {
		in, out := &in.NativeTransportMaxConcurrentRequestsInBytes, &out.NativeTransportMaxConcurrentRequestsInBytes
		*out = new(int)
		**out = **in
	}
	if in.NativeTransportMaxConcurrentRequestsInBytesPerIp != nil {
		in, out := &in.NativeTransportMaxConcurrentRequestsInBytesPerIp, &out.NativeTransportMaxConcurrentRequestsInBytesPerIp
		*out = new(int)
		**out = **in
	}
	if in.NativeTransportMaxFrameSizeInMb != nil {
		in, out := &in.NativeTransportMaxFrameSizeInMb, &out.NativeTransportMaxFrameSizeInMb
		*out = new(int)
		**out = **in
	}
	if in.NativeTransportMaxNegotiableProtocolVersion != nil {
		in, out := &in.NativeTransportMaxNegotiableProtocolVersion, &out.NativeTransportMaxNegotiableProtocolVersion
		*out = new(int)
		**out = **in
	}
	if in.NativeTransportMaxRequestsPerSecond != nil {
		in, out := &in.NativeTransportMaxRequestsPerSecond, &out.NativeTransportMaxRequestsPerSecond
		*out = new(int)
		**out = **in
	}
	if in.NativeTransportMaxThreads != nil {
		in, out := &in.NativeTransportMaxThreads, &out.NativeTransportMaxThreads
		*out = new(int)
		**out = **in
	}
	if in.NativeTransportRateLimitingEnabled != nil {
		in, out := &in.NativeTransportRateLimitingEnabled, &out.NativeTransportRateLimitingEnabled
		*out = new(bool)
		**out = **in
	}
	if in.NativeTransportReceiveQueueCapacityInBytes != nil {
		in, out := &in.NativeTransportReceiveQueueCapacityInBytes, &out.NativeTransportReceiveQueueCapacityInBytes
		*out = new(int)
		**out = **in
	}
	if in.NetworkAuthorizer != nil {
		in, out := &in.NetworkAuthorizer, &out.NetworkAuthorizer
		*out = new(string)
		**out = **in
	}
	if in.NetworkingCacheSizeInMb != nil {
		in, out := &in.NetworkingCacheSizeInMb, &out.NetworkingCacheSizeInMb
		*out = new(int)
		**out = **in
	}
	if in.NumTokens != nil {
		in, out := &in.NumTokens, &out.NumTokens
		*out = new(int)
		**out = **in
	}
	if in.OtcBacklogExpirationIntervalMs != nil {
		in, out := &in.OtcBacklogExpirationIntervalMs, &out.OtcBacklogExpirationIntervalMs
		*out = new(int)
		**out = **in
	}
	if in.OtcCoalescingEnoughCoalescedMessages != nil {
		in, out := &in.OtcCoalescingEnoughCoalescedMessages, &out.OtcCoalescingEnoughCoalescedMessages
		*out = new(int)
		**out = **in
	}
	if in.OtcCoalescingStrategy != nil {
		in, out := &in.OtcCoalescingStrategy, &out.OtcCoalescingStrategy
		*out = new(string)
		**out = **in
	}
	if in.OtcCoalescingWindowUs != nil {
		in, out := &in.OtcCoalescingWindowUs, &out.OtcCoalescingWindowUs
		*out = new(int)
		**out = **in
	}
	if in.PaxosCacheSizeInMb != nil {
		in, out := &in.PaxosCacheSizeInMb, &out.PaxosCacheSizeInMb
		*out = new(int)
		**out = **in
	}
	if in.PeriodicCommitlogSyncLagBlockInMs != nil {
		in, out := &in.PeriodicCommitlogSyncLagBlockInMs, &out.PeriodicCommitlogSyncLagBlockInMs
		*out = new(int)
		**out = **in
	}
	if in.PermissionsCacheMaxEntries != nil {
		in, out := &in.PermissionsCacheMaxEntries, &out.PermissionsCacheMaxEntries
		*out = new(int)
		**out = **in
	}
	if in.PermissionsUpdateIntervalInMs != nil {
		in, out := &in.PermissionsUpdateIntervalInMs, &out.PermissionsUpdateIntervalInMs
		*out = new(int)
		**out = **in
	}
	if in.PermissionsValidityInMs != nil {
		in, out := &in.PermissionsValidityInMs, &out.PermissionsValidityInMs
		*out = new(int)
		**out = **in
	}
	if in.PhiConvictThreshold != nil {
		in, out := &in.PhiConvictThreshold, &out.PhiConvictThreshold
		*out = new(string)
		**out = **in
	}
	if in.PreparedStatementsCacheSizeMb != nil {
		in, out := &in.PreparedStatementsCacheSizeMb, &out.PreparedStatementsCacheSizeMb
		*out = new(int)
		**out = **in
	}
	if in.RangeRequestTimeoutInMs != nil {
		in, out := &in.RangeRequestTimeoutInMs, &out.RangeRequestTimeoutInMs
		*out = new(int)
		**out = **in
	}
	if in.RangeTombstoneListGrowthFactor != nil {
		in, out := &in.RangeTombstoneListGrowthFactor, &out.RangeTombstoneListGrowthFactor
		*out = new(string)
		**out = **in
	}
	if in.ReadRequestTimeoutInMs != nil {
		in, out := &in.ReadRequestTimeoutInMs, &out.ReadRequestTimeoutInMs
		*out = new(int)
		**out = **in
	}
	if in.RejectRepairCompactionThreshold != nil {
		in, out := &in.RejectRepairCompactionThreshold, &out.RejectRepairCompactionThreshold
		*out = new(int)
		**out = **in
	}
	if in.RepairCommandPoolFullStrategy != nil {
		in, out := &in.RepairCommandPoolFullStrategy, &out.RepairCommandPoolFullStrategy
		*out = new(string)
		**out = **in
	}
	if in.RepairCommandPoolSize != nil {
		in, out := &in.RepairCommandPoolSize, &out.RepairCommandPoolSize
		*out = new(int)
		**out = **in
	}
	if in.RepairSessionMaxTreeDepth != nil {
		in, out := &in.RepairSessionMaxTreeDepth, &out.RepairSessionMaxTreeDepth
		*out = new(int)
		**out = **in
	}
	if in.RepairSessionSpaceInMb != nil {
		in, out := &in.RepairSessionSpaceInMb, &out.RepairSessionSpaceInMb
		*out = new(int)
		**out = **in
	}
	if in.RepairedDataTrackingForPartitionReadsEnabled != nil {
		in, out := &in.RepairedDataTrackingForPartitionReadsEnabled, &out.RepairedDataTrackingForPartitionReadsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.RepairedDataTrackingForRangeReadsEnabled != nil {
		in, out := &in.RepairedDataTrackingForRangeReadsEnabled, &out.RepairedDataTrackingForRangeReadsEnabled
		*out = new(bool)
		**out = **in
	}
	if in.ReplicaFilteringProtection != nil {
		in, out := &in.ReplicaFilteringProtection, &out.ReplicaFilteringProtection
		*out = new(ReplicaFilteringProtectionOptions)
		(*in).DeepCopyInto(*out)
	}
	if in.ReportUnconfirmedRepairedDataMismatches != nil {
		in, out := &in.ReportUnconfirmedRepairedDataMismatches, &out.ReportUnconfirmedRepairedDataMismatches
		*out = new(bool)
		**out = **in
	}
	if in.RequestScheduler != nil {
		in, out := &in.RequestScheduler, &out.RequestScheduler
		*out = new(string)
		**out = **in
	}
	if in.RequestSchedulerId != nil {
		in, out := &in.RequestSchedulerId, &out.RequestSchedulerId
		*out = new(string)
		**out = **in
	}
	if in.RequestSchedulerOptions != nil {
		in, out := &in.RequestSchedulerOptions, &out.RequestSchedulerOptions
		*out = new(RequestSchedulerOptions)
		(*in).DeepCopyInto(*out)
	}
	if in.RequestTimeoutInMs != nil {
		in, out := &in.RequestTimeoutInMs, &out.RequestTimeoutInMs
		*out = new(int)
		**out = **in
	}
	if in.RoleManager != nil {
		in, out := &in.RoleManager, &out.RoleManager
		*out = new(string)
		**out = **in
	}
	if in.RolesCacheMaxEntries != nil {
		in, out := &in.RolesCacheMaxEntries, &out.RolesCacheMaxEntries
		*out = new(int)
		**out = **in
	}
	if in.RolesUpdateIntervalInMs != nil {
		in, out := &in.RolesUpdateIntervalInMs, &out.RolesUpdateIntervalInMs
		*out = new(int)
		**out = **in
	}
	if in.RolesValidityInMs != nil {
		in, out := &in.RolesValidityInMs, &out.RolesValidityInMs
		*out = new(int)
		**out = **in
	}
	if in.RowCacheClassName != nil {
		in, out := &in.RowCacheClassName, &out.RowCacheClassName
		*out = new(string)
		**out = **in
	}
	if in.RowCacheKeysToSave != nil {
		in, out := &in.RowCacheKeysToSave, &out.RowCacheKeysToSave
		*out = new(int)
		**out = **in
	}
	if in.RowCacheSavePeriod != nil {
		in, out := &in.RowCacheSavePeriod, &out.RowCacheSavePeriod
		*out = new(int)
		**out = **in
	}
	if in.RowCacheSizeInMb != nil {
		in, out := &in.RowCacheSizeInMb, &out.RowCacheSizeInMb
		*out = new(int)
		**out = **in
	}
	if in.ServerEncryptionOptions != nil {
		in, out := &in.ServerEncryptionOptions, &out.ServerEncryptionOptions
		*out = new(encryption.ServerEncryptionOptions)
		(*in).DeepCopyInto(*out)
	}
	if in.SlowQueryLogTimeoutInMs != nil {
		in, out := &in.SlowQueryLogTimeoutInMs, &out.SlowQueryLogTimeoutInMs
		*out = new(int)
		**out = **in
	}
	if in.SnapshotBeforeCompaction != nil {
		in, out := &in.SnapshotBeforeCompaction, &out.SnapshotBeforeCompaction
		*out = new(bool)
		**out = **in
	}
	if in.SnapshotLinksPerSecond != nil {
		in, out := &in.SnapshotLinksPerSecond, &out.SnapshotLinksPerSecond
		*out = new(int)
		**out = **in
	}
	if in.SnapshotOnDuplicateRowDetection != nil {
		in, out := &in.SnapshotOnDuplicateRowDetection, &out.SnapshotOnDuplicateRowDetection
		*out = new(bool)
		**out = **in
	}
	if in.SnapshotOnRepairedDataMismatch != nil {
		in, out := &in.SnapshotOnRepairedDataMismatch, &out.SnapshotOnRepairedDataMismatch
		*out = new(bool)
		**out = **in
	}
	if in.SstablePreemptiveOpenIntervalInMb != nil {
		in, out := &in.SstablePreemptiveOpenIntervalInMb, &out.SstablePreemptiveOpenIntervalInMb
		*out = new(int)
		**out = **in
	}
	if in.StreamEntireSstables != nil {
		in, out := &in.StreamEntireSstables, &out.StreamEntireSstables
		*out = new(bool)
		**out = **in
	}
	if in.StreamThroughputOutboundMegabitsPerSec != nil {
		in, out := &in.StreamThroughputOutboundMegabitsPerSec, &out.StreamThroughputOutboundMegabitsPerSec
		*out = new(int)
		**out = **in
	}
	if in.StreamingConnectionsPerHost != nil {
		in, out := &in.StreamingConnectionsPerHost, &out.StreamingConnectionsPerHost
		*out = new(int)
		**out = **in
	}
	if in.StreamingKeepAlivePeriodInSecs != nil {
		in, out := &in.StreamingKeepAlivePeriodInSecs, &out.StreamingKeepAlivePeriodInSecs
		*out = new(int)
		**out = **in
	}
	if in.StreamingSocketTimeoutInMs != nil {
		in, out := &in.StreamingSocketTimeoutInMs, &out.StreamingSocketTimeoutInMs
		*out = new(int)
		**out = **in
	}
	if in.TableCountWarnThreshold != nil {
		in, out := &in.TableCountWarnThreshold, &out.TableCountWarnThreshold
		*out = new(int)
		**out = **in
	}
	if in.ThriftFramedTransportSizeInMb != nil {
		in, out := &in.ThriftFramedTransportSizeInMb, &out.ThriftFramedTransportSizeInMb
		*out = new(int)
		**out = **in
	}
	if in.ThriftMaxMessageLengthInMb != nil {
		in, out := &in.ThriftMaxMessageLengthInMb, &out.ThriftMaxMessageLengthInMb
		*out = new(int)
		**out = **in
	}
	if in.ThriftPreparedStatementsCacheSizeMb != nil {
		in, out := &in.ThriftPreparedStatementsCacheSizeMb, &out.ThriftPreparedStatementsCacheSizeMb
		*out = new(int)
		**out = **in
	}
	if in.TombstoneFailureThreshold != nil {
		in, out := &in.TombstoneFailureThreshold, &out.TombstoneFailureThreshold
		*out = new(int)
		**out = **in
	}
	if in.TombstoneWarnThreshold != nil {
		in, out := &in.TombstoneWarnThreshold, &out.TombstoneWarnThreshold
		*out = new(int)
		**out = **in
	}
	if in.TracetypeQueryTtl != nil {
		in, out := &in.TracetypeQueryTtl, &out.TracetypeQueryTtl
		*out = new(int)
		**out = **in
	}
	if in.TracetypeRepairTtl != nil {
		in, out := &in.TracetypeRepairTtl, &out.TracetypeRepairTtl
		*out = new(int)
		**out = **in
	}
	if in.TrackWarnings != nil {
		in, out := &in.TrackWarnings, &out.TrackWarnings
		*out = new(TrackWarnings)
		(*in).DeepCopyInto(*out)
	}
	if in.TraverseAuthFromRoot != nil {
		in, out := &in.TraverseAuthFromRoot, &out.TraverseAuthFromRoot
		*out = new(bool)
		**out = **in
	}
	if in.TrickleFsync != nil {
		in, out := &in.TrickleFsync, &out.TrickleFsync
		*out = new(bool)
		**out = **in
	}
	if in.TrickleFsyncIntervalInKb != nil {
		in, out := &in.TrickleFsyncIntervalInKb, &out.TrickleFsyncIntervalInKb
		*out = new(int)
		**out = **in
	}
	if in.TruncateRequestTimeoutInMs != nil {
		in, out := &in.TruncateRequestTimeoutInMs, &out.TruncateRequestTimeoutInMs
		*out = new(int)
		**out = **in
	}
	if in.UnloggedBatchAcrossPartitionsWarnThreshold != nil {
		in, out := &in.UnloggedBatchAcrossPartitionsWarnThreshold, &out.UnloggedBatchAcrossPartitionsWarnThreshold
		*out = new(int)
		**out = **in
	}
	if in.UseDeterministicTableId != nil {
		in, out := &in.UseDeterministicTableId, &out.UseDeterministicTableId
		*out = new(bool)
		**out = **in
	}
	if in.UseOffheapMerkleTrees != nil {
		in, out := &in.UseOffheapMerkleTrees, &out.UseOffheapMerkleTrees
		*out = new(bool)
		**out = **in
	}
	if in.UserDefinedFunctionFailTimeout != nil {
		in, out := &in.UserDefinedFunctionFailTimeout, &out.UserDefinedFunctionFailTimeout
		*out = new(int)
		**out = **in
	}
	if in.UserDefinedFunctionWarnTimeout != nil {
		in, out := &in.UserDefinedFunctionWarnTimeout, &out.UserDefinedFunctionWarnTimeout
		*out = new(int)
		**out = **in
	}
	if in.UserFunctionTimeoutPolicy != nil {
		in, out := &in.UserFunctionTimeoutPolicy, &out.UserFunctionTimeoutPolicy
		*out = new(string)
		**out = **in
	}
	if in.ValidationPreviewPurgeHeadStartInSec != nil {
		in, out := &in.ValidationPreviewPurgeHeadStartInSec, &out.ValidationPreviewPurgeHeadStartInSec
		*out = new(int)
		**out = **in
	}
	if in.WindowsTimerInterval != nil {
		in, out := &in.WindowsTimerInterval, &out.WindowsTimerInterval
		*out = new(int)
		**out = **in
	}
	if in.WriteRequestTimeoutInMs != nil {
		in, out := &in.WriteRequestTimeoutInMs, &out.WriteRequestTimeoutInMs
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new CassandraYaml.
func (in *CassandraYaml) DeepCopy() *CassandraYaml {
	if in == nil {
		return nil
	}
	out := new(CassandraYaml)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *EmbeddedObjectMeta) DeepCopyInto(out *EmbeddedObjectMeta) {
	*out = *in
	if in.Labels != nil {
		in, out := &in.Labels, &out.Labels
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new EmbeddedObjectMeta.
func (in *EmbeddedObjectMeta) DeepCopy() *EmbeddedObjectMeta {
	if in == nil {
		return nil
	}
	out := new(EmbeddedObjectMeta)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *FullQueryLoggerOptions) DeepCopyInto(out *FullQueryLoggerOptions) {
	*out = *in
	if in.ArchiveCommand != nil {
		in, out := &in.ArchiveCommand, &out.ArchiveCommand
		*out = new(string)
		**out = **in
	}
	if in.RollCycle != nil {
		in, out := &in.RollCycle, &out.RollCycle
		*out = new(string)
		**out = **in
	}
	if in.Block != nil {
		in, out := &in.Block, &out.Block
		*out = new(bool)
		**out = **in
	}
	if in.MaxQueueWeight != nil {
		in, out := &in.MaxQueueWeight, &out.MaxQueueWeight
		*out = new(int)
		**out = **in
	}
	if in.MaxLogSize != nil {
		in, out := &in.MaxLogSize, &out.MaxLogSize
		*out = new(int)
		**out = **in
	}
	if in.MaxArchiveRetries != nil {
		in, out := &in.MaxArchiveRetries, &out.MaxArchiveRetries
		*out = new(int)
		**out = **in
	}
	if in.LogDir != nil {
		in, out := &in.LogDir, &out.LogDir
		*out = new(string)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new FullQueryLoggerOptions.
func (in *FullQueryLoggerOptions) DeepCopy() *FullQueryLoggerOptions {
	if in == nil {
		return nil
	}
	out := new(FullQueryLoggerOptions)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Group) DeepCopyInto(out *Group) {
	*out = *in
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Group.
func (in *Group) DeepCopy() *Group {
	if in == nil {
		return nil
	}
	out := new(Group)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *JvmOptions) DeepCopyInto(out *JvmOptions) {
	*out = *in
	if in.HeapSize != nil {
		in, out := &in.HeapSize, &out.HeapSize
		x := (*in).DeepCopy()
		*out = &x
	}
	if in.HeapNewGenSize != nil {
		in, out := &in.HeapNewGenSize, &out.HeapNewGenSize
		x := (*in).DeepCopy()
		*out = &x
	}
	if in.AdditionalOptions != nil {
		in, out := &in.AdditionalOptions, &out.AdditionalOptions
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new JvmOptions.
func (in *JvmOptions) DeepCopy() *JvmOptions {
	if in == nil {
		return nil
	}
	out := new(JvmOptions)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *K8ssandraCluster) DeepCopyInto(out *K8ssandraCluster) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new K8ssandraCluster.
func (in *K8ssandraCluster) DeepCopy() *K8ssandraCluster {
	if in == nil {
		return nil
	}
	out := new(K8ssandraCluster)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *K8ssandraCluster) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *K8ssandraClusterCondition) DeepCopyInto(out *K8ssandraClusterCondition) {
	*out = *in
	if in.LastTransitionTime != nil {
		in, out := &in.LastTransitionTime, &out.LastTransitionTime
		*out = (*in).DeepCopy()
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new K8ssandraClusterCondition.
func (in *K8ssandraClusterCondition) DeepCopy() *K8ssandraClusterCondition {
	if in == nil {
		return nil
	}
	out := new(K8ssandraClusterCondition)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *K8ssandraClusterList) DeepCopyInto(out *K8ssandraClusterList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]K8ssandraCluster, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new K8ssandraClusterList.
func (in *K8ssandraClusterList) DeepCopy() *K8ssandraClusterList {
	if in == nil {
		return nil
	}
	out := new(K8ssandraClusterList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *K8ssandraClusterList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *K8ssandraClusterSpec) DeepCopyInto(out *K8ssandraClusterSpec) {
	*out = *in
	if in.Auth != nil {
		in, out := &in.Auth, &out.Auth
		*out = new(bool)
		**out = **in
	}
	if in.Cassandra != nil {
		in, out := &in.Cassandra, &out.Cassandra
		*out = new(CassandraClusterTemplate)
		(*in).DeepCopyInto(*out)
	}
	if in.Stargate != nil {
		in, out := &in.Stargate, &out.Stargate
		*out = new(stargatev1alpha1.StargateClusterTemplate)
		(*in).DeepCopyInto(*out)
	}
	if in.Reaper != nil {
		in, out := &in.Reaper, &out.Reaper
		*out = new(reaperv1alpha1.ReaperClusterTemplate)
		(*in).DeepCopyInto(*out)
	}
	if in.Medusa != nil {
		in, out := &in.Medusa, &out.Medusa
		*out = new(medusav1alpha1.MedusaClusterTemplate)
		(*in).DeepCopyInto(*out)
	}
	if in.ExternalDatacenters != nil {
		in, out := &in.ExternalDatacenters, &out.ExternalDatacenters
		*out = make([]string, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new K8ssandraClusterSpec.
func (in *K8ssandraClusterSpec) DeepCopy() *K8ssandraClusterSpec {
	if in == nil {
		return nil
	}
	out := new(K8ssandraClusterSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *K8ssandraClusterStatus) DeepCopyInto(out *K8ssandraClusterStatus) {
	*out = *in
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]K8ssandraClusterCondition, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
	if in.Datacenters != nil {
		in, out := &in.Datacenters, &out.Datacenters
		*out = make(map[string]K8ssandraStatus, len(*in))
		for key, val := range *in {
			(*out)[key] = *val.DeepCopy()
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new K8ssandraClusterStatus.
func (in *K8ssandraClusterStatus) DeepCopy() *K8ssandraClusterStatus {
	if in == nil {
		return nil
	}
	out := new(K8ssandraClusterStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *K8ssandraStatus) DeepCopyInto(out *K8ssandraStatus) {
	*out = *in
	if in.Cassandra != nil {
		in, out := &in.Cassandra, &out.Cassandra
		*out = new(v1beta1.CassandraDatacenterStatus)
		(*in).DeepCopyInto(*out)
	}
	if in.Stargate != nil {
		in, out := &in.Stargate, &out.Stargate
		*out = new(stargatev1alpha1.StargateStatus)
		(*in).DeepCopyInto(*out)
	}
	if in.Reaper != nil {
		in, out := &in.Reaper, &out.Reaper
		*out = new(reaperv1alpha1.ReaperStatus)
		(*in).DeepCopyInto(*out)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new K8ssandraStatus.
func (in *K8ssandraStatus) DeepCopy() *K8ssandraStatus {
	if in == nil {
		return nil
	}
	out := new(K8ssandraStatus)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ParameterizedClass) DeepCopyInto(out *ParameterizedClass) {
	*out = *in
	if in.Parameters != nil {
		in, out := &in.Parameters, &out.Parameters
		*out = new(map[string]string)
		if **in != nil {
			in, out := *in, *out
			*out = make(map[string]string, len(*in))
			for key, val := range *in {
				(*out)[key] = val
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ParameterizedClass.
func (in *ParameterizedClass) DeepCopy() *ParameterizedClass {
	if in == nil {
		return nil
	}
	out := new(ParameterizedClass)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *ReplicaFilteringProtectionOptions) DeepCopyInto(out *ReplicaFilteringProtectionOptions) {
	*out = *in
	if in.CachedRowsWarnThreshold != nil {
		in, out := &in.CachedRowsWarnThreshold, &out.CachedRowsWarnThreshold
		*out = new(int)
		**out = **in
	}
	if in.CachedRowsFailThreshold != nil {
		in, out := &in.CachedRowsFailThreshold, &out.CachedRowsFailThreshold
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new ReplicaFilteringProtectionOptions.
func (in *ReplicaFilteringProtectionOptions) DeepCopy() *ReplicaFilteringProtectionOptions {
	if in == nil {
		return nil
	}
	out := new(ReplicaFilteringProtectionOptions)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *RequestSchedulerOptions) DeepCopyInto(out *RequestSchedulerOptions) {
	*out = *in
	if in.ThrottleLimit != nil {
		in, out := &in.ThrottleLimit, &out.ThrottleLimit
		*out = new(int)
		**out = **in
	}
	if in.DefaultWeight != nil {
		in, out := &in.DefaultWeight, &out.DefaultWeight
		*out = new(int)
		**out = **in
	}
	if in.Weights != nil {
		in, out := &in.Weights, &out.Weights
		*out = new(map[string]int)
		if **in != nil {
			in, out := *in, *out
			*out = make(map[string]int, len(*in))
			for key, val := range *in {
				(*out)[key] = val
			}
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new RequestSchedulerOptions.
func (in *RequestSchedulerOptions) DeepCopy() *RequestSchedulerOptions {
	if in == nil {
		return nil
	}
	out := new(RequestSchedulerOptions)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *SubnetGroups) DeepCopyInto(out *SubnetGroups) {
	*out = *in
	if in.Subnets != nil {
		in, out := &in.Subnets, &out.Subnets
		*out = make([]Group, len(*in))
		copy(*out, *in)
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SubnetGroups.
func (in *SubnetGroups) DeepCopy() *SubnetGroups {
	if in == nil {
		return nil
	}
	out := new(SubnetGroups)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *TrackWarnings) DeepCopyInto(out *TrackWarnings) {
	*out = *in
	if in.CoordinatorReadSize != nil {
		in, out := &in.CoordinatorReadSize, &out.CoordinatorReadSize
		*out = new(int)
		**out = **in
	}
	if in.LocalReadSize != nil {
		in, out := &in.LocalReadSize, &out.LocalReadSize
		*out = new(int)
		**out = **in
	}
	if in.RowIndexSize != nil {
		in, out := &in.RowIndexSize, &out.RowIndexSize
		*out = new(int)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new TrackWarnings.
func (in *TrackWarnings) DeepCopy() *TrackWarnings {
	if in == nil {
		return nil
	}
	out := new(TrackWarnings)
	in.DeepCopyInto(out)
	return out
}
